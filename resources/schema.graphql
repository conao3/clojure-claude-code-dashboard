interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type CacheCreation {
  ephemeral_5m_input_tokens: Int!
  ephemeral_1h_input_tokens: Int!
}

type AssistantMessageUsage {
  input_tokens: Int!
  cache_creation_input_tokens: Int!
  cache_read_input_tokens: Int!
  cache_creation: CacheCreation
  output_tokens: Int!
  service_tier: String!
}

type AssistantMessageContent {
  type: String!
  text: String
  thinking: String
  signature: String
  id: String
  name: String
  input: String
  tool_use_id: String
  content: String
}

type AssistantMessageMessage {
  model: String!
  messageId: String!
  type: String!
  role: String!
  content: [AssistantMessageContent!]!
  stop_reason: String
  stop_sequence: String
  usage: AssistantMessageUsage!
}

type AssistantMessage implements Node & Message {
  id: ID!
  projectId: String!
  sessionId: String!
  messageId: String!
  rawMessage: String!

  cwd: String!
  gitBranch: String
  isSidechain: Boolean!
  message: AssistantMessageMessage!
  parentUuid: String
  requestId: String!
  timestamp: String!
  userType: String!
  version: String!
}

type StructuredPatchHunk {
  oldStart: Int!
  oldLines: Int!
  newStart: Int!
  newLines: Int!
  lines: [String!]!
}

type ToolUseResult {
  type: String
  filePath: String
  oldString: String
  newString: String
  content: String
  structuredPatch: [StructuredPatchHunk!]
}

type UserMessageContent {
  type: String!
  text: String
  tool_use_id: String
  content: String
  toolUseResult: ToolUseResult
}

type UserMessageMessage {
  role: String!
  content: [UserMessageContent!]!
}

type UserMessageThinkingMetadata {
  level: String!
  disabled: Boolean!
  triggers: [String!]!
}

type UserMessage implements Node & Message {
  id: ID!
  projectId: String!
  sessionId: String!
  messageId: String!
  rawMessage: String!

  cwd: String!
  gitBranch: String
  isSidechain: Boolean!
  message: UserMessageMessage!
  parentUuid: String
  thinkingMetadata: UserMessageThinkingMetadata
  timestamp: String!
  userType: String!
  version: String!
}

type FileBackup {
  backupFileName: String!
  version: Int!
  backupTime: String!
}

type FileHistorySnapshot {
  messageId: String!
  trackedFileBackups: String!
  timestamp: String!
}

type FileHistorySnapshotMessage implements Node & Message {
  id: ID!
  projectId: String!
  sessionId: String!
  messageId: String!
  rawMessage: String!
  snapshot: FileHistorySnapshot!
  isSnapshotUpdate: Boolean!
}

type UnknownMessage implements Node & Message {
  id: ID!
  projectId: String!
  sessionId: String!
  messageId: String!
  rawMessage: String!
}

type BrokenMessage implements Node & Message {
  id: ID!
  projectId: String!
  sessionId: String!
  messageId: String!
  rawMessage: String!
}

type QueueOperationMessage implements Node & Message {
  id: ID!
  projectId: String!
  sessionId: String!
  messageId: String!
  rawMessage: String!
  operation: String!
  timestamp: String!
  content: String
  queueSessionId: String!
}

type SystemMessageCompactMetadata {
  trigger: String!
  preTokens: Int!
}

type SystemMessage implements Node & Message {
  id: ID!
  projectId: String!
  sessionId: String!
  messageId: String!
  rawMessage: String!
  parentUuid: String
  logicalParentUuid: String
  isSidechain: Boolean!
  userType: String!
  cwd: String!
  version: String!
  gitBranch: String
  subtype: String!
  content: String!
  isMeta: Boolean!
  timestamp: String!
  level: String!
  compactMetadata: SystemMessageCompactMetadata
}

type SummaryMessage implements Node & Message {
  id: ID!
  projectId: String!
  sessionId: String!
  messageId: String!
  rawMessage: String!
  summary: String!
  leafUuid: String!
}

type MessageConnection { edges: [MessageEdge!]! pageInfo: PageInfo! }
type MessageEdge { cursor: String! node: Message }
interface Message implements Node {
  id: ID!
  projectId: String!
  sessionId: String!
  messageId: String!
  rawMessage: String!
}

type SessionConnection { edges: [SessionEdge!]! pageInfo: PageInfo! }
type SessionEdge { cursor: String! node: Session }
type Session implements Node {
  id: ID!
  projectId: String!
  sessionId: String!
  createdAt: String!
  messages(first: Int, after: String, last: Int, before: String): MessageConnection!
}

type ProjectConnection { edges: [ProjectEdge!]! pageInfo: PageInfo! }
type ProjectEdge { cursor: String! node: Project }
type Project implements Node {
  id: ID!
  projectId: String!
  name: String!
  sessions(first: Int, after: String, last: Int, before: String): SessionConnection!
}


### Root

type Query {
  hello: String
  node(id: ID!): Node
  projects(first: Int, after: String, last: Int, before: String): ProjectConnection!
}
